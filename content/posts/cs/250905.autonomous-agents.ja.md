---
# 基本情報
title: "Autonomous Agents: 個々の行動から複雑なComplex Systemsまで"
date: 2025-09-05T10:00:00+08:00
summary: "最近、『Nature of Code』を再読し、以前のメモを更新しました。この記事では、Autonomous Agentの基本概念と、それらが形成するComplex Systemについて紹介します。"
draft: false

# カテゴリーとタグ
categories: ["Computer Science", "Notes"]
tags: ["Autonomous Agents", "Steering Behaviors", "Complex System", "Simulation"]

# カバー画像
cover: "https://pic.aspi-rin.top/2025/09/f05ea15d2d18134174819f57acba4f96.jpg"

# 機能スイッチ
katex: true

comments: true
showLicense: true
showRelated: true
---


<iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/rulatte/embed/zxveERB?default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/rulatte/pen/zxveERB">
  Untitled</a> by rulatte (<a href="https://codepen.io/rulatte">@rulatte</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

## Autonomous Agentとは？

人工知能やコンピュータグラフィックスにおいて、Autonomous Agentとは、リーダーやグローバルな計画に影響されることなく、環境内でどのように行動するかを自ら決定できるエンティティです。重要な構成要素は3つあります。

- 限定された知覚：昆虫が視覚や嗅覚を通じて周囲の世界を理解できるように、環境や自身の内部状態を知覚する能力。
- 情報処理と意思決定：知覚を行動に変換すること。例えば、魚が捕食者の接近を感知すると、反対方向に逃避力を加えます。
- 自律性：Autonomous Agentにはリーダーがおらず、分散化された個々の行動です（特定の状況によります）。

> アリやシロアリのコロニーの人工シミュレーションは、Autonomous Agentシステムの優れたデモンストレーションです。ミッチェル・レズニックの『タートル、ターマイト、トラフィックジャム』（*Turtles, Termites, and Traffic Jams,* Bradford Books, 1997）を読むことをお勧めします。

## Vehicleと*Steering*

> 1980年代後半、コンピュータ科学者のCraig Reynoldsは、アニメーションキャラクターのためのSteering Behaviorsを開発しました。これらのビヘイビアにより、個々の要素は、逃げる、さまよう、到着する、追跡する、避けるなどの戦略を用いて、デジタル環境を現実的な方法でナビゲートできます。その後、1999年の論文「Steering Behaviors for Autonomous Characters」で、ReynoldsはAutonomous Agentを説明するために「Vehicle」という用語を使用しました。
>
> したがって、Autonomous Agentクラスを `Vehicle` と名付けます。

Reynoldsは、理想化されたVehicleの動きを3つの層 (layer)で説明しました。

- **Action selection**：目標が何かを決定します。Vehicleには目標（または複数の目標）があり、その目標に基づいて行動（または行動の組み合わせ）を選択できます。
- **Steering**：目標を「ステアリング力」に変換します。これは本質的に速度の差であり、ステアリング力 = 望ましい速度 – 現在の速度です。
- **Locomotion**：ステアリング力を動きに変換します。

### Seek

次のシナリオを考えてみましょう：Vehicleがターゲットを探しています。

![](https://pic.aspi-rin.top/2025/09/900310a2eaf375fc29ec16e9a601e779.jpg)

Vehicleが自身の状態（速度と現在の移動方向）と環境（ターゲットの位置）の知覚に基づいて、ターゲットに向かって操縦するためのインテリジェントな決定を下すようにしたいです。

望ましい速度は、Vehicleの現在位置からターゲットの位置までのベクトル `p5.Vector.sub(target, position)` として設定できます。このベクトルの大きさは最高速度に設定されるため、Vehicleに `maxspeed` プロパティを追加する必要があります。

$$
\text{steering force} = \text{desired velocity} - \text{current velocity}
$$

![](https://pic.aspi-rin.top/2025/09/bd04347a276c6a0f274d276b850ae207.jpg)

ステアリング力は、望ましい速度から現在の速度を引いたものに等しいです。

また、Vehicleが望ましい速度にすぐに変更できるかどうかを決定するために、Vehicleの操縦性も考慮する必要があります。これを行うには、Vehicleに `maxforce` プロパティを追加して、ステアリング力の大きさを制限する必要があります。

すべてをまとめると、`p5.Vector` ターゲットを受け取り、そのターゲットに向かうステアリング力を計算する `seek()` というメソッドを作成できます。

```JavaScript
seek(target) {
  let desired = p5.Vector.sub(target,this.position);
  desired.setMag(this.maxspeed);
  let steer = p5.Vector.sub(desired, this.velocity);
  steer.limit(this.maxforce);
  this.applyForce(steer);
}
```

### Arrive

Vehicleがターゲットに非常に近い場合、「オーバーシュート」を避けるために、望ましい速度をターゲットまでの距離に比例させることができます。例えば、`desired.mult(0.05)` のようにします。

![](https://pic.aspi-rin.top/2025/09/634f31e3b7256f2b7b9bfaaabf3be6bc.jpg)

Reynoldsは、より複雑なアプローチを説明しました。ターゲットの周りに半径rの円を想像してください。Vehicleがこの円の内側にある場合、徐々に減速し、ターゲットで速度が0になります。

![](https://pic.aspi-rin.top/2025/09/7d07b68ef7a19784a235d1a98e029dd2.jpg)

```JavaScript
let d = desired.mag();  // ターゲットを指すベクトルの大きさ
if (d < 100) {
  let m = map(d, 0, 100, 0, this.maxspeed);
  desired.setMag(m);
} else {
  desired.setMag(this.maxspeed);
}
```

### Wander

SeekとArriveはどちらも、各ビヘイビアに対して単一のベクトル、つまり望ましい速度を計算すると見なすことができます。Reynoldsが提案したすべての誘導ビヘイビアは、このパターンに従います。

Wanderの目標はランダムな動きではなく、しばらく一方向に移動してから、少し別の方向にさまようという感覚です。次のフレームの方向は前のフレームの方向に関連しているため、各フレームでランダムな操縦方向を生成するよりも興味深い動きが生まれます。

まず、Vehicleは前方の固定距離（現在の速度の方向）に将来の位置を予測します。次に、その位置を中心として半径rの円を描き、円周上の点をランダムに選択します。この点は、各フレームで円の周りをランダムに移動し、Vehicleのターゲットとなるため、その望ましい速度はその方向を指します。

![](https://pic.aspi-rin.top/2025/09/ad6796dbda506c4de64edacbe7ca9b47.jpg)

Wanderビヘイビアは、Vehicleの前方の円周上のランダムな点をターゲットとして扱います。

> ランダム性を利用してVehicleのステアリングを駆動しますが、このランダム性を円で制約することで、Vehicleの動きがぎくしゃくしたり、完全にランダムに見えたりするのを防ぎます。

### **Flow-field following**

Flow-fieldとは何ですか？キャンバスをグリッドと見なし、各セルに方向ベクトルがあると想像してください。Vehicleがキャンバスを横切って移動するとき、「ねえ、私の下にある矢印は何ですか？それが私が望む速度です！」と尋ねます。

![](https://pic.aspi-rin.top/2025/09/b92703f92875c27c4646f3c4f23c5cc9.jpg)

パーリンノイズを使用すると、ノイズ値を0〜1から0〜2πの角度にマッピングできます（ただし、パーリンノイズは正規分布しているため、左に移動する傾向があります）。

![](https://pic.aspi-rin.top/2025/09/e39c15fb39faa56211564b0e8ece2188.jpg)

```JavaScript
let xoff = 0;
for (let i = 0; i < this.cols; i++) {
  let yoff = 0;
  for (let j = 0; j < this.rows; j++) {
    let angle = map(noise(xoff, yoff), 0, 1, 0, TWO_PI);
    this.field[i][j] = p5.Vector.fromAngle(angle);  // 角度から単位ベクトルを生成
    yoff += 0.1;
  }
  xoff += 0.1;
}
```

### Path Following

**Simple Path Following**

![](https://pic.aspi-rin.top/2025/09/876a490354ddb3fe9e36e8e3d6f0e25e.jpg)

Path Followingには、パス、Vehicle、将来の位置、法線、およびターゲットが必要です。

パスとは何ですか？簡単な方法は、パスを一連の接続された点として定義することです。パスには半径があり、これは道路の幅です。

![](https://pic.aspi-rin.top/2025/09/1cdf17c95af390c00c368a79bad2a931.jpg)

現在の方向に沿って将来の位置を予測します。ステアリング力は、Vehicleがパスから逸脱した場合にのみ適用する必要があります。

![](https://pic.aspi-rin.top/2025/09/587ffadb61aef3cec630e6f24644a81f.jpg)

法線点を見つけ、法線点の前にターゲットを設定し（ターゲットはパス上にあります）、最後に望ましい速度を計算します。

**Path Following with Multiple Segments**

重要なのは、パスに沿ってターゲットポイントを見つける方法です。つまり、最初に正しい線分を見つけてから、その線分上の法線点を計算する必要があります。

![](https://pic.aspi-rin.top/2025/09/ac65d681f37f54b0393cfad73d027f15.jpg)

Reynoldsが提案した解決策は、パス上にある最も近い法線点を選択することです。

## Complex Systems

論理的な次のステップとして、エージェントは物理的な環境だけでなく、仲間のエージェントの行動も知覚し、それに応じて行動できる必要があります。

Complex Systemは、しばしばその部分の総和以上のシステムとして定義されます。システムの個々の要素は非常に単純で理解しやすいかもしれませんが、システム全体の振る舞いは非常に複雑で、インテリジェントで、予測が困難な場合があります。

> 小さな這うアリを想像してみてください。アリはAutonomous Agentです。環境を知覚し（触角を使って化学信号の方向と強さに関する情報を収集します）、これらの信号に基づいて移動の決定を下すことができます。しかし、単独で行動する1匹のアリが巣を作ったり、食物を集めたり、女王を守ったりすることができますか？アリは、直接の環境しか知覚できない単純なユニットです。しかし、アリのコロニーはComplex Systemであり、協調して働く超個体であり、その構成要素は困難で複雑な目標を達成するために協力します。

Complex Systemを構築するための3つのコア原則：

1. 単純なユニット間の短距離関係：環境の知覚が制限されています。
2. 単純なユニットは並行して動作します：各サイクルで、各ユニットは独自のステアリング力を計算します。
3. システム全体が**Emergence**を示します：複雑な行動、パターン、および知性は、単純なユニット間の相互作用から現れる可能性があります。この現象は、アリのコロニー、渡りのパターン、地震、雪の結晶など、自然界で発生します。

Complex Systemの他の3つの特徴は、議論を組み立て、ソフトウェアシミュレーションのガイドラインを提供するのに役立ちます。これはあいまいな特徴のセットであり、すべてのComplex Systemがすべてを持っているわけではありません。

1. 非線形性：Complex Systemのこの側面は、しばしばバタフライ効果と呼ばれ、カオス理論の研究のパイオニアである数学者で気象学者のEdward Norton Lorenzに由来します。初期条件の変化と結果の間に線形関係がないため、非線形と呼ばれます。初期条件の小さな変化が結果に大きな影響を与える可能性があります。多くの0と1で構成されるシステムであっても、1ビットを変更するだけで、結果は完全に異なります。非線形システムは、カオスシステムのスーパーセットです。
2. 競争と協力：構成要素の間には競争と協力の両方が存在します。
3. フィードバック：Complex Systemには、システムの出力をシステムにフィードバックするループが含まれていることが多く、その動作に正または負の方向に影響を与えます。

### Flocking

**Flocking**は、鳥、魚、昆虫など、多くの生物に見られる群れの動物の行動です。1986年、ReynoldsはFlocking行動のコンピュータシミュレーションを作成し、そのアルゴリズムを論文*Flocks, Herds, and Schools: A Distributed Behavioral Model*で文書化しました。

Reynoldsは、Flockingシステムの要素を説明するために、*boid*（鳥のようなオブジェクトを指す架空の言葉）という用語を使用しました。

Flockingの3つのルール：

![](https://pic.aspi-rin.top/2025/09/8f57534a650f96544125e12fde9f8e11.jpg)

- 分離：隣人との衝突を避けるために操縦します。
- 整列：隣人と同じ方向に操縦します。
    - 望ましい速度は、隣人の平均速度に設定されます。
- 結束：隣人の中心に向かって操縦します（群れと一緒にとどまるため）。

これらの単純なローカルルールは、システムレベルで自然で現実的なFlockingパターンを形成できます。